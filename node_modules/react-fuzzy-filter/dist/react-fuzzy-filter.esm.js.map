{"version":3,"file":"react-fuzzy-filter.esm.js","sources":["../src/FilterResults.tsx","../src/InputFilter.tsx","../src/index.ts"],"sourcesContent":["import Fuse, { FuseOptions } from \"fuse.js\";\nimport React, { Fragment, useEffect, useState } from \"react\";\nimport { Emitter, Event } from \"./behaviorStore\";\n\nexport type PreFilterHandler<T> = (\n  match: string,\n  items: T[],\n  fuse: typeof Fuse\n) => T[];\n\nexport interface PreFilter<T> {\n  regex: RegExp;\n  handler: PreFilterHandler<T>;\n}\nexport interface FilterResultsProps<T> {\n  children: (items: T[]) => React.ReactNode;\n  items: T[];\n  defaultAllItems?: boolean;\n  fuseConfig: FuseOptions<T>;\n  prefilters?: Array<PreFilter<T>>;\n}\n\nexport type FilterResults<T> = React.FunctionComponent<FilterResultsProps<T>>;\n\nexport default function filterResultsFactory<T>(\n  store: Emitter<Event>\n): FilterResults<T> {\n  const Results: FilterResults<T> = (props: FilterResultsProps<T>) => {\n    const [searchVal, setSearch] = useState(\"\");\n\n    useEffect(() => {\n      const unsubscribe = store.on(({ v }) => {\n        setSearch(v);\n      });\n      return unsubscribe;\n    }, []);\n\n    const prefilterItems = (s: string): { items: T[]; search: string } => {\n      let items = props.items;\n      (props.prefilters || []).forEach(({ regex, handler }) => {\n        const matches = s.match(regex) || [];\n        s = s.replace(regex, \"\").trim();\n        matches.forEach(match => {\n          items = handler(match, items, Fuse);\n        });\n      });\n      return { items, search: s };\n    };\n\n    const filterItems = (s: string): T[] => {\n      const { items, search } = prefilterItems(s || \"\");\n      if (search.trim() === \"\") {\n        return props.defaultAllItems ? items : [];\n      } else {\n        const fuse = new Fuse(items, props.fuseConfig);\n        return fuse.search(search);\n      }\n    };\n\n    const filteredItems = filterItems(searchVal);\n    // wrap with Fragment to fix type issue\n    return <Fragment>{props.children(filteredItems)}</Fragment>;\n  };\n  Results.displayName = \"FilterResults\";\n  Results.defaultProps = {\n    defaultAllItems: true,\n    prefilters: [],\n  };\n\n  return Results;\n}\n","import debounce from \"debounce\";\nimport React, { useCallback, useEffect, useState } from \"react\";\nimport { Emitter, Event, EventType } from \"./behaviorStore\";\n\nexport interface InputFilterProps {\n  classPrefix?: string;\n  initialSearch?: string;\n  inputProps?: React.InputHTMLAttributes<HTMLInputElement>;\n  onChange?: (value: string) => string;\n  debounceTime?: number;\n}\n\nexport type InputFilter = React.ComponentType<InputFilterProps>;\nconst defaultProps = {\n  classPrefix: \"react-fuzzy-filter\",\n  debounceTime: 0,\n  inputProps: {},\n  onChange: (value: string) => value,\n};\n\nexport default function inputFilterFactory(store: Emitter<Event>): InputFilter {\n  function updateValue(value: string, onChange: (value: string) => string) {\n    const overrideValue = onChange(value);\n    store({ t: EventType.Input, v: overrideValue });\n  }\n\n  const Input: React.FunctionComponent<InputFilterProps> = (\n    props: InputFilterProps\n  ) => {\n    const initialSearch = props.initialSearch || \"\";\n    const onChange = props.onChange || defaultProps.onChange;\n    const debounceTime = props.debounceTime || defaultProps.debounceTime;\n\n    const [inputValue, setValue] = useState(initialSearch);\n    const debouncedUpdate = useCallback(debounce(updateValue, debounceTime), [\n      debounceTime,\n    ]);\n\n    useEffect(() => {\n      const unsubscribe = store.on(({ v, t }) => {\n        if (t === EventType.External) {\n          setValue(v);\n        }\n      });\n      return unsubscribe;\n    }, []);\n\n    useEffect(() => {\n      updateValue(initialSearch, onChange);\n    }, [initialSearch, onChange]);\n\n    const handleChange = ({\n      target: { value },\n    }: React.ChangeEvent<HTMLInputElement>) => {\n      setValue(value);\n      if (debounceTime) {\n        debouncedUpdate(value, onChange);\n      } else {\n        updateValue(value, onChange);\n      }\n    };\n\n    return (\n      <input\n        className={`${props.classPrefix}__input`}\n        onChange={handleChange}\n        value={inputValue}\n        {...props.inputProps}\n      />\n    );\n  };\n\n  Input.displayName = \"InputFilter\";\n  Input.defaultProps = defaultProps;\n\n  return Input;\n}\n","import behaviorStore, { Emitter, Event, EventType } from \"./behaviorStore\";\nimport filterResultsFactory from \"./FilterResults\";\nimport inputFilterFactory from \"./InputFilter\";\n\nexport {\n  FilterResults,\n  FilterResultsProps,\n  PreFilter,\n  PreFilterHandler,\n} from \"./FilterResults\";\nexport { FuseOptions, FuseResult } from \"fuse.js\";\nexport { InputFilter, InputFilterProps } from \"./InputFilter\";\n\nexport default function fuzzyFilterFactory<T>() {\n  const store: Emitter<Event> = behaviorStore<Event>({\n    t: EventType.Initial,\n    v: \"\",\n  });\n  return {\n    FilterResults: filterResultsFactory<T>(store),\n    InputFilter: inputFilterFactory(store),\n    changeInputValue: (value: string) => {\n      store({\n        t: EventType.External,\n        v: typeof value !== \"string\" ? \"\" : value,\n      });\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAuDe,YAAY,YAAA,EAAM;;;;;;;;wBASX;;;;0CAElB;;;;;;;;;;KAHF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBCrCyD;YAGjD;YACA,eAAA;;;;mCAIoD;;QAExD;;;;;;;;;;;;;;QAYW,QAAA,GAAA,EAAA,CAAA,CAAA;;uBACI;;6BAOE,CAAC;;;;aACjB;;;;;;IAeL;;iCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;2BChDmC;;;GAAA;;;;;;;;;;;;;;;"}